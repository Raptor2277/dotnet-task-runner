using System.Diagnostics;
using System.Text.Json;

namespace task_scheduling_api.Utils
{
    public static class PythonScriptRunner
    {
        private static readonly string pythonExecutableCommand = "python";
        private static readonly string pythonScriptsPath = ".\\pythonScripts";
        private static readonly string scriptExecutionRootPath = ".\\pythonExecution";

        private static readonly string pythonScriptsInfoPath = Path.Combine(pythonScriptsPath, "scriptsInfo.json");

        public static PythonScriptInfo? GetInfoByName(string name)
        {
            var infos = JsonSerializer.Deserialize<PythonScriptInfo[]>(File.ReadAllText(pythonScriptsInfoPath));

            return infos?.FirstOrDefault(e => e.ScriptName == name);
        }

        public static string CreateExecutionDirectory(string scriptPath)
        {
            var workDir = Path.Combine(scriptExecutionRootPath, Guid.NewGuid().ToString());

            if (Directory.Exists(workDir)) 
                throw new Exception("working directory already axists, this should never happen");

            Directory.CreateDirectory(workDir);

            var source = Path.Combine(pythonScriptsPath, scriptPath);
            var destination = Path.Combine(workDir, scriptPath);
            File.Copy(source, destination);

            return workDir;
        }

        public static void CleanWorkingDirectory(string folderName)
        {
            Directory.Delete(folderName, true);
        }

        public static async Task<(bool success, string workDir)> RunScript(string scriptName)
        {
            var workDir = CreateExecutionDirectory(scriptName);

            try
            {
                ProcessStartInfo start = new ProcessStartInfo();
                start.WorkingDirectory = Path.Combine(Environment.CurrentDirectory, workDir);
                start.FileName = pythonExecutableCommand;
                start.Arguments = scriptName;
                start.UseShellExecute = false;// Do not use OS shell
                start.CreateNoWindow = true; // We don't need new window
                start.RedirectStandardOutput = true;// Any output, generated by application will be redirected back
                start.RedirectStandardError = true; // Any error in standard output will be redirected back (for example exceptions)
                using var process = Process.Start(start);

                if (process == null)
                    return (false, workDir);

                string stderr = await process.StandardError.ReadToEndAsync(); // Here are the exceptions from our Python script
                string stdout = await process.StandardOutput.ReadToEndAsync(); // Here is the result of StdOut(for example: print "test")

                File.WriteAllText(Path.Combine(workDir, "stdout.txt"), stdout);
                File.WriteAllText(Path.Combine(workDir, "stderr.txt"), stderr);

                if (stderr.Length > 0)
                    return (false, workDir);

                return (true, workDir);

            }
            catch (Exception ex)
            {
                File.WriteAllText(Path.Combine(workDir, "exception.txt"), ex.ToString());

                return (false, workDir);
            }
        }
    }
}
